"""
This module handles the commit-reveal mechanism for fairness and transparency.
"""

import hashlib
import math
import secrets
from typing import List
import merkletools 
from .rng import LCG, secret_to_seed

def generate_secret(num_bytes=32) -> bytes:
    """
    Generate a secure random secret.

    :param num_bytes: Number of random bytes.
    :return: Random bytes object.
    """
    return secrets.token_bytes(num_bytes)

def commit_secret(secret: bytes) -> str:
    """
    Commit to a secret by returning its SHA-256 hash.

    :param secret: The secret bytes.
    :return: Hex-encoded SHA-256 hash string as the commitment.
    """
    return hashlib.sha256(secret).hexdigest()

def verify_secret(secret: bytes, commitment: str) -> bool:
    """
    Verify that a secret corresponds to a given commitment.

    :param secret: The original secret bytes.
    :param commitment: The commitment hash provided earlier.
    :return: True if they match, False otherwise.
    """
    return commit_secret(secret) == commitment

# This is somewhat computationally expensive but serves as a PoC
def verify_normal_sequence(secret: bytes, commitment: str, sequence: List[float],
                           mu=0.0, sigma=1.0, tolerance=1e-6) -> bool:
    """
    Verify that a given sequence of numbers was generated by the LCG's random_normal
    method seeded with the provided secret.

    :param secret: The original secret bytes.
    :param commitment: The commitment hash provided earlier.
    :param sequence: List of numbers to verify.
    :param mu: Mean used in the random_normal generation.
    :param sigma: Standard deviation used in the random_normal generation.
    :param tolerance: Acceptable difference between expected and actual numbers.
    :return: True if the sequence matches, False otherwise.
    """
    # Step 1: Verify that the secret matches the commitment
    if not verify_secret(secret, commitment):
        print("Secret does not match the commitment.")
        return False

    # Step 2: Derive the seed from the secret
    seed = secret_to_seed(secret)

    # Step 3: Initialize the LCG
    rng = LCG(seed)

    # Step 4: Generate the expected sequence and compare
    for index, number in enumerate(sequence):
        expected_number = rng.random_normal(mu=mu, sigma=sigma)
        if not math.isclose(expected_number, number, abs_tol=tolerance):
            print(f"Mismatch at index {index}: expected {expected_number}, got {number}")
            return False

    # All numbers matched within the specified tolerance
    return True

def hash_leaf(data: str) -> str:
    """
    Hash a leaf node for the Merkle tree.

    :param data: The data to hash.
    :return: Hex-encoded SHA-256 hash string.
    """
    return hashlib.sha256(data.encode('utf-8')).hexdigest()


def build_merkle_tree(sequence: List[float]) -> merkletools.MerkleTools:
    """
    Build a Merkle tree from a sequence of numbers.

    :param sequence: List of numbers to include in the Merkle tree.
    :return: An instance of MerkleTools containing the tree.
    """
    mt = merkletools.MerkleTools(hash_type="sha256")
    # Add each number as a leaf (converted to string)
    for number in sequence:
        mt.add_leaf(str(number), do_hash=True)
    mt.make_tree()
    return mt


def get_merkle_root(mt: merkletools.MerkleTools) -> str:
    """
    Get the Merkle root from a Merkle tree.

    :param mt: An instance of MerkleTools containing the tree.
    :return: Hex-encoded Merkle root.
    """
    return mt.get_merkle_root()


def get_merkle_proof(mt: merkletools.MerkleTools, index: int) -> List[str]:
    """
    Get the Merkle proof for a specific leaf.

    :param mt: An instance of MerkleTools containing the tree.
    :param index: Index of the leaf for which to generate the proof.
    :return: List of hashes representing the Merkle proof.
    """
    return mt.get_proof(index)


def verify_merkle_proof(leaf: str, proof: List[str], root: str) -> bool:
    """
    Verify a Merkle proof for a given leaf and root.

    :param leaf: The original data of the leaf.
    :param proof: List of hashes representing the Merkle proof.
    :param root: The Merkle root to verify against.
    :return: True if the proof is valid, False otherwise.
    """
    mt = merkletools.MerkleTools(hash_type="sha256")
    return mt.validate_proof(proof, hashlib.sha256(leaf.encode('utf-8')).hexdigest(), root)

# This might be a bit better than the previous verification function
# data says the merkle verifier is 6.86 times faster than the previous one for 1000 samples
# and 3412x faster for 1000_000 samples
def verify_normal_sequence_with_merkle(secret: bytes, commitment: str, merkle_root: str,
                                      sequence: List[float], proofs: List[List[str]],
                                      indices: List[int],
                                      mu=0.0, sigma=1.0,
                                      tolerance=1e-6) -> bool:
    """
    Verify that specific elements of a given sequence were generated by the LCG's random_normal
    method seeded with the provided secret, using Merkle proofs.

    :param secret: The original secret bytes.
    :param commitment: The commitment hash provided earlier.
    :param merkle_root: The Merkle root of the sequence.
    :param sequence: List of numbers to verify.
    :param proofs: List of Merkle proofs corresponding to the sequence elements.
    :param indices: List of indices of the elements being verified.
    :param mu: Mean used in the random_normal generation.
    :param sigma: Standard deviation used in the random_normal generation.
    :param tolerance: Acceptable difference between expected and actual numbers.
    :return: True if all provided elements are valid, False otherwise.
    """
    # Step 1: Verify that the secret matches the commitment
    if not verify_secret(secret, commitment):
        print("Secret does not match the commitment.")
        return False

    # Step 2: Derive the seed from the secret
    seed = secret_to_seed(secret)

    # Step 3: Initialize the LCG
    rng = LCG(seed)

    # Step 4: Generate the expected sequence up to the maximum index
    max_index = max(indices)
    expected_sequence = []
    for _ in range(max_index + 1):
        expected_sequence.append(rng.random_normal(mu=mu, sigma=sigma))

    # Step 5: Verify each specified element using Merkle proofs
    mt = merkletools.MerkleTools(hash_type="sha256")
    # Since we don't have the entire tree, we can verify each proof individually
    for idx, number, proof in zip(indices, sequence, proofs):
        expected_number = expected_sequence[idx]
        if not math.isclose(expected_number, number, abs_tol=tolerance):
            print(f"Mismatch at index {idx}: expected {expected_number}, got {number}")
            return False
        # Verify the Merkle proof
        leaf = str(number)
        if not verify_merkle_proof(leaf, proof, merkle_root):
            print(f"Invalid Merkle proof for index {idx}.")
            return False

    # All specified numbers matched and proofs are valid
    return True